
/*
    所有权与借用:
        - Rust 之所以能成为万众瞩目的语言，就是因为其内存安全性。在以往，内存安全几乎都是通过
        GC的方式实现，但是GC会引来性能、内存占用以及stop the world等问题，在高性能场景和系统编
        程上是不可接受的，因此Rust采用了 与众不同（错误之源）的方式: 所有权系统
*/
/*
    所有权:
            计算机中的内存资源申请与释放，在程序需要内存时申请，在不需要的时候释放空间，成了重中之重，
        也是编程语言设计的难点之一，在计算机不断演变的过程中，出现了以下三种流派:
            1.垃圾回收机制(GC)，在程序运行时不断不定时寻找不再使用的内存, 典型代表: Java、Go;
            2.手动管理内存的分配和释放，在程序中，通过函数调用的方式来申请和释放内存, 典型代表: C++;
            3.通过所有权管理内存，编译器在编译时会根据一系列规则进行检查, 典型代表:Rust;
                
            Rust 选择了第三种，最牛逼的是，这种检查只发生在编译器，因此对于程序运行期，不会有任何性能上的损失;


        栈: 后进先出
            - 增加数据称之为 进栈，移出数据称之为 出栈;
            - 值存在栈中，所有的数据都必须占用已知且固定大小的内存控件，假设数据大小未知，则无法取出想要的数据;

        堆: 
            - 对于大小未知或可变化的数据，都可以存在堆中。
            - 当向堆放入数据时，需要请求一定大小的内存空间，操作系统在堆的某处找到一块足够大的空位，把它标记为已使用,
            并返回一个表示该未知地址的指针，该过程称之为在堆上分配内存，简称为 “分配”(allocating);
            - 接着该指针会被推入到栈中，因为指针的大小是固定的，可以通过指针来获取堆中实际数据的内存地址，从而获取对应的数据;
        
            - 堆是一种缺乏组织的数据结构。
                比喻: 去餐馆吃饭，告诉服务员有几个人，就会安排一个大桌子(堆上分配的内存空间)，有人迟到了，就会根据桌号(栈中的指针)来查找;

        堆栈的性能区别:
            - 写入数据: 
                - 入栈比堆上分配内存要快，因为入栈操作系统无须分配新的内存空间，只需要将新的数据放与栈顶即可;
                - 堆需要先要分配内存，则需要做更多的工作让操作系统必须找到一块足够存放数据的内存空间，接着做一
                些记录为下一次的分配;

            - 读取数据:
                - 得益于CPU高速缓存，使得CPU可以减少对内存的分配，高速缓存和内存的访问速度差异在10倍以上;
                - 栈数据可以直接存储在CPU高速缓存中，而堆数据只能存储在内存中。所以访问堆上的数据比访问栈
                中的数据要慢10倍以上，因为需要先访问栈，再通过栈上的指针访问内存中的数据;

            总结: CPU处理和分配在栈上的数据比在堆上的数据效率更高;

        所有权与堆栈:
            - 当调用函数并给函数传递参数(包括指向堆上数据的指针函数的局部变量)会依次被压入栈中，当函数调用结束时，
            这些值将从栈中按照相反的顺序依次移除;

            - 但由于堆缺乏组织，跟踪这些数据的何时分配和释放是非常重要的，否则堆上的数据将产生内存泄漏，导致这些
            数据无法被回收。因此 “Rust所有权系统” 可以为我们提供解决方法;

            - 总结: Rust必须要明白堆栈的原理，对于我们理解所有权的工作原理会有很大的帮助;

    所有权原则(必记):
        1.Rust中每一个值都被一个变量所拥有, 该变量被称之为所有者;
        2.一个值同时只能被一个变量所拥有, 或者说一个值只能拥有一个所有这;
        3.当所有者(变量)离开作用域范围时，这个值将被丢弃(drop);
    
*/

// 1、变量作用域 (rust与其他语言没有区别)
fn demo01(){  // s 在这里无效，因为没有声明
    let s = "变量作用域";  // 从此处起，s 是有效的
    // 使用 s
    println!("{}", s);

}  // 此作用域已结束，s不再有效

// 2、String类型
 /*
    let s = "hello";  s是被硬编码进程序里的字符串，类型为&str。字符串的面值是很方便的，但并不适用所有场景;
        - 字符串字面值是不可变的, 因为被硬编码到程序代码中;
        - 并非所有字符串的值都能在编写代码时得知;
    需求: 字符串在运行时，通过都用户动态输入然后存储在内存中, 这种情况字符串字面值就不符合要求。因此, Rust提供了
    “动态字符串类型(String)”, 该类型被分配到堆上，因此可以动态伸缩，也能存储编译时大小未知的文本;
*/ 
fn demo02(){
    // 定义并初始化动态字符串类型变量s
    let mut s = String::from("hello");  // 调用String中的from方法，String存在堆上是动态的;
    // 在 s 字符串后面追加字面值
    s.push_str(" world!");
    println!("{}", s);

}

// 3、变量绑定背后的数据交互
/*
    转移所有权
        - 将5绑定给x变量，接着拷贝x的值赋给y，最终x和y都等于5，
        因此值的内存大小都是一样的，都会存在栈中，无须在堆上分配内存;
        let x = 5;
        let y = x;
        - 在栈中拷贝数据的消耗，远比在堆上分配并创建内存空间快得多;
*/
fn demo03(){
    /*
        看似rust会从栈中自动拷贝s1赋值给s2，但是必须是rust的基本类型;
        因为s1并不是rust基本类型，所以rust不会自动拷贝s1赋值给s2;
        动态String由于值的大小不会固定，所以是将指针存放在栈中，真实的值存放在指针指向的堆中;
        
        这种赋值分为两种情况去分析: 
            - 1.拷贝 ”String和存储在堆上的字节数组“ ，如果该语句是拷贝所有数据(深拷贝),那无论
            是String本身还是底层的堆上的数据，都会被全部拷贝，这对于性能都会造成非常大的影响;

            - 2.只拷贝 String 本身，这样拷贝速度会非常快，因为在64位机器上拷贝了（8bit的指针、
            8bit的长度、8bit的容量）总计24字节，但是会带来所有权规则的问题，其中的一条规则是，
            “一个值只允许有一个所有者，而现在这个值（堆上的真实字符串数据）有两个所有者 (s1和s2);

            ”一个值拥有两个所有者“ 的问题:
                当s1和s2变量离开作用域后，Rust会自动调用drop函数并清理变量中的堆内存。由于s1和
            s2都是指向同一个位置，就会导致释放相同的内存，会导致 二次释放(doulbe free)错误，也是
            非常典型的内存安全性BUG之一，会导致内存污染，最终导致潜在的安全漏洞;

                因此，Rust通过转移所有权来解决该问题,当s1赋值给s2后，Rust会认为s1不再有效，因为
            也无须在s1离开作用域后drop任何东西，这就把 s1的所有权 转移给了 s2，转移后 s1 马上失效;
        
    */
    let s1 = String::from("hello");  // 动态String
    let _s2 = s1; 
    // 引用被转移所有权后的变量，会报错
    // println!("{}", s1); // value borrowed here after move
    /*
        Rust所有权规则:
            1.Rust中每一个值都被一个变量所拥有，该变量称之为值的所有者;
            2.一个值同时只能被一个变量所拥有的，或者说一个值只能拥有一个所有者;
            3.当所有者(变量)离开作用域范围时，该值将被丢弃(drop);
    */
}

/*
    4、克隆与拷贝
    - 克隆(深拷贝)
        Rust永远不会自动创建数据的 深拷贝，所以任何自动拷贝都不是深拷贝，那么对性能的影响会比较小;
    若想深拷贝，则可以通过.clone()方法来实现

    - 拷贝(浅拷贝) 
        浅拷贝只发生在栈上，因此性能非常高，在日常变成中，浅拷贝无处不在，可以理解为在栈中做的深拷贝;

    Copy特征类型: (任何基本类型的组合可以copy)
            - 所有整数类型，比如: u32
            - 布尔类型, bool
            - 所有浮点型, 比如: f64
            - 字符类型, char
            - 元组, 但必须是包含的类型也都是Copy的类型，比如: (i32, u32等), 但(i32, String)就不是
            - 不可变引用 &T, 例如转移所有权中的最后一个例子，但是要注意: 可变引用 &mut T是不可以Copy的
*/
fn demo04(){
    let x:&str = "hello world!";  // 定义一个字符串
    let y = x; // 将x的所有权转移给y变量
    // 按照所有权转移的概念, 这段代码理应会报错, 但是并没有报错
    // 原因是之前的例子引用的是String::from("hello world")创建的值的所有权，
    // 而这里只是引用了二进制中的字符串"hello world!"
    println!("x: {}   y: {}", x, y);  

    // 克隆(深拷贝)
    // Rust永远不会自动创建数据的 深拷贝，所以任何自动拷贝都不是深拷贝，那么对性能的影响会比较小;
    // 若想深拷贝，则可以通过.clone()方法来实现
    let s1 = String::from("hello s1"); // 创建一个动态字符串s1
    let s2 = s1.clone(); // 克隆s1给s2  深拷贝
    println!("s1:{} -- s2:{}", s1, s2);
    // 注意: 若频繁使用clone()会对性能造成非常大的影响，建议谨慎使用

    // 拷贝(浅拷贝)
    // 浅拷贝只发生在栈上，因此性能非常高，在日常变成中，浅拷贝无处不在
    let s3 = 5;
    let s4 = s3;  // 可以理解为在栈中做的深拷贝
    // 此处不会报错的原因是 基本类型是已知大小，所以会存储在栈上
    // 所以这里没有深浅拷贝的区别，可以理解为在栈上的深拷贝
    // Rust有个特征叫Copy，比如存在栈中的整型，是一个拥有Copy特征的类型，所以在旧变量赋值给其他变量仍然可用;
    println!("s3:{} -- s4:{}", s3, s4); 
    /*
        Copy特征类型: (任何基本类型的组合可以copy)
            - 所有整数类型，比如: u32
            - 布尔类型, bool
            - 所有浮点型, 比如: f64
            - 字符类型, char
            - 元组, 但必须是包含的类型也都是Copy的类型，比如: (i32, u32等), 但(i32, String)就不是
            - 不可变引用 &T, 例如转移所有权中的最后一个例子，但是要注意: 可变引用 &mut T是不可以Copy的
    */

}

/*
    5、函数传值和返回: 值传递，一样会发生 移动 或 赋值，就跟let语句一样，拥有所有权和作用域;
*/
fn makes_copy(some_integer: i32){  // some_integer 进入作用域
    println!("{}", some_integer);
}
fn takes_ownership(some_string: String){  // some_string 进入作用域
    println!("{}", some_string);

}

fn gives_ownership(some_string: String) -> String {  // some_string 进入作用域
    println!("{}", some_string);
    some_string  // return some_string  将所有权返回给调用者
}

/*
    6、引用与借用:
        若仅通过所有权转移来获取一个值，那么rust的程序写起来会非常复杂，所以Rust也希望能像其他语言一样
    使用某个变量的指针或者引用。
        Rust通过 借用(Borrowing) 来达成上述的目的，“获取变量的引用，称之为借用”。就像先从某个地方借用完
    再物归原主。

    总结: 
        - 同一时刻，只能拥有要么一个可变引用，要么一个不可变引用;
        - 引用必须是有效的;
*/
// 7、引用与解引用
fn demo05(){
    // 常规引用类型是一个指针类型，指向对象存储的内存地址
    let x = 5;
    let y = &x;  // y是x的一个引用
    assert_eq!(5, x);
    assert_eq!(5, *y);  // *y是解引用，才能与5进行比较

    // 报错，因为他们类型不同，5是整型，y是引用类型
    // assert_eq!(5, y);  // no implementation for `{integer} == &{integer}`
}

// 8、不可变引用与可变引用
fn demo06(){
    let s1 = String::from("hello s1");
    let len = calculate_length(&s1);  
    /*
        s1无须通过 calculate_length 返回，也可以继续使用,原因:
            1.无需先通过函数传入所有权，然后再通过函数返回来转出所有权，代码更加简洁;
            2.calculate_length 的参数 s 类型从 String 变为 &String; (&String为不可变引用，具备Copy特征)
            3.&符号可以理解为引用，允许你使用值，但不是获取所有权;
    */
    println!("The length of '{}' is {}", s1, len);

    // 为什么称之为 不可变引用，原因是若想在change函数中修改s1的值，那么就会报错，所以称之为不可变引用
    // change(&s1);  // 报错
    let mut s2 = String::from("hello s2");
    change(&mut s2);  // 通过 &mut 改为可变引用即可
    println!("s2: {}", s2);
}

// 计算字符串长度
fn calculate_length(s: &String) -> usize{  // s 是对&String的引用
    s.len()
}  // s离开了作用域，但是并不拥有引用值的所有权

// 修改字符串
fn change(some_string: &mut String){
    // 在字符串后面追加字符
    some_string.push_str("，Wowo!");  // 报错:consider changing this to be a mutable reference: `&mut String`
}

// 9、可变引用限制: 同一作用域，特定数据只能有一个可变引用;
fn demo07(){
    // 定义一个可变字符串
    let mut s = String::from("hello demo07 mut s");

    // let r1 = &mut s;  
    // let r2 = &mut s;  // cannot borrow `s` as mutable more than once at a time
    // 报错原因是，在r1必须要持续到最后一个位置println!，在r1的创建和最后的一次使用之间，
    // 又尝试创建第二个可变引用r2, 也就会导致 borrow checker 错误
    // println!("{}, {}", r1, r2);
    /*
        Rust之所有出现  borrow checker 特性，是因为出于安全考虑，好处就是
    在编译器就避免数据竞争问题, 不然会造成一下问题:
        1.两个或更多指针同时访问同一数据;
        2.至少有一个指针被用来写入数据;
        3.没有同步数据访问的机制;

        数据竞争会导致很多超出预期的问题，难以在运行时追踪，并且难以诊断与修复。而
    Rust避免了这种情况的发生，甚至不会编译存在数据竞争的代码;
    */ 
    // 通过 {} 大括号利用作用域解决编译不通过问题
    {
        let r1 = &mut s;
        println!("r1: {}", r1);
    } // r1 在这里离开作用域，之后可以创建一个新的引用
    let r2 = &mut s;
    println!("r2: {}", r2);

} 

// 10、可变引用与不可变引用不能同时出现
fn demo08(){
    let mut s = String::from("hello demo08 s");
    // 不可变引用
    let r1 = &s;  // 没问题
    let r2 = &s;  // 没问题
    // // 因为s已经被借用为 不可变引用类型，所以无法成为可变引用类型
    // let r3 = &mut s; // mutable borrow occurs here
    // println!("r1:{}  r2:{} r3: {}", r1, r2, r3);

    /*
        多个不可变借用被允许是因为没有人会去修改数据，每个人都只读着一分数据，所有不用担心数据被污染。
    早期的编译器，引用作用域和变量作用域时一直的，这会对日常的开发造成很大的困扰，需要非常小心去使用
    可变、不可变变量的借用，免得无法通过编译等问题;
    */
    println!("r1:{}  r2:{}", r1, r2);
    // 新编译器会在这里结束r1, r2的作用域

    let r3 = &mut s; // 此时s被不可变引用 成为 可变引用
    println!("r3:{}", r3);
}  // 老编译器中，r1, r2, r3 会在这里结束作用域， 新编译器 r3在这里结束作用域


/*
    11、NLL（Non-Lexical Lifetimes）: 
        编译器优化行为称之为NLL，专门用于找到某个引用在作用域(})结束前就不再被使用的代码位置。
    因此Rust会发现潜在的Bug,在开发阶段会减慢开发速度，但是长期来看，大幅减少了后续开发和运维的成本;

    - 悬垂引用（Dangling References）
        悬垂引用也叫做 悬垂指针，意思是指针指向某个值后，若这个值被释放掉，而指针仍然存在，并指向
    的内存可能 ”不存在任何值“ 或 ”已被其他变量重新使用“。Rust编译器可以确保引用永远不会变成悬垂状态。
        当拥有一些数据的引用，编译器可以确保数据不会再其引用之前被释放，想要释放数据，必须先停止引用。

        总结: 想要释放某个值，必须停止后续引用;
*/ 
// 悬垂引用问题
fn demo09(){
    let reference_to_nothing = dangle();
    println!("dangle: {}", reference_to_nothing);
}

// // 返回了一个借用的值，调用并接收的变量无法找到值的来源
// fn dangle() -> &String{  // expected named lifetime parameter
//     let s = String::from("hello dangle");
//     &s // 返回字符串s的引用
// } // 这里s离开作用域并被丢弃，内存被释放，报错

// 直接返回String解决，这样是通过将String的所有权转移给外面的调用者
fn dangle() -> String{  // expected named lifetime parameter
    let s = String::from("hello dangle");
    s // 返回字符串s的引用
} // 这里s离开作用域并被丢弃，内存被释放，报错




fn main() {
    demo01();
    demo02();
    demo03();
    demo04();

    let i = 5;
    makes_copy(i);  
    // i32 是copy，所有i可以继续使用
    println!("{}", i);  // 报错

    let s = String::from("hello");  // s 进入作用域
    takes_ownership(s); // 将s的值移动到函数中

    // 此处s不再有效
    // println!("{}", s);  // 报错
    // 若想解决这个问题，让s的所有权由函数内部转移出来，可以通过函数的return将所有权返回
    let s2 = String::from("hello");  // s 进入作用域
    let s3 = gives_ownership(s2); // 将s的值移动到函数中
    println!("{}", s3);

    // 引用与解引用
    demo05();   

    // 不可变引用 与 可变引用
    demo06();

    // 可变引用限制
    demo07();

    // 可变引用与不可变引用不能同时出现
    demo08();

    // 悬垂问题
    demo09();
}
