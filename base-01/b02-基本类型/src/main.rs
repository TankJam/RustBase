use num::complex::Complex; // å¯¼å…¥numåº“

// åŸºæœ¬æ•°æ®ç±»å‹
/*
    æ•°å€¼ç±»å‹:
        æœ‰ç¬¦å·: i8, i16, i32, i64, isize

        æ— ç¬¦å·: u8, u16, u32, u64, usize

        æµ®ç‚¹æ•°: f32, f64

        ç†æ•°ã€å¤æ•°

    å­—ç¬¦ä¸²:
        &str

    å¸ƒå°”ç±»å‹:
        true, false

    å­—ç¬¦ç±»å‹:
        Unicode, å•ä¸ªå­—ç¬¦ä¸º4ä¸ªå­—èŠ‚

    å•å…ƒç±»å‹:
        ()

    ç±»å‹æ¨å¯¼ ä¸ æ ‡æ³¨
        - åœ¨å¤§å¤šæ•°æƒ…å†µä¸‹ï¼Œrustç¼–è¯‘å™¨éƒ½èƒ½æ ¹æ®å˜é‡çš„ä½¿ç”¨è‡ªåŠ¨æ¨å¯¼å‡ºå˜é‡çš„ç±»å‹
        - ä½†æ˜¯åœ¨æŸç§æƒ…å†µä¸‹æ— æ³•æ¨å¯¼ï¼Œæ‰€ä»¥éœ€è¦æ‰‹åŠ¨å»åšä¸€ä¸ªç±»å‹çš„æ ‡æ³¨
*/

// æ•°å€¼ç±»å‹
fn number_type(){
// ç±»å‹æ¨å¯¼ ä¸ æ ‡æ³¨
    // ç¼–è¾‘å™¨ä¸çŸ¥é“è¿™ä¸ªåˆ°åº•æ˜¯å­—ç¬¦ä¸²ã€æ•´å½¢è¿˜æ˜¯æµ®ç‚¹å‹
    // let guess = "9527".parse().expect("Not a number"); // é€šè¿‡ .parse().expect è¿›è¡Œæ ‡æ³¨
    let guess:i32 = "9527".parse().expect("Not a number"); // é€šè¿‡ .parse().expect è¿›è¡Œæ ‡æ³¨
    println!("value: {}", guess);

    /*
        1ã€æ•´æ•°ç±»å‹:
            i: integer  æœ‰ç¬¦å·
                i8: -128 ~ 127
            u: unsigned æ— ç¬¦å·
                u8: 0 ~ 255

            isizeã€usize å–å†³äºCPUçš„ç±»å‹ï¼Œ32ä¸64ä½ã€‚

            è‹¥è¶…å‡ºèŒƒå›´åˆ™ç±»å‹æº¢å‡ºã€‚
    */

    /*
        2ã€æµ®ç‚¹ç±»å‹:
            f32ã€f64

            æµ®ç‚¹å‹çš„æ¯”è¾ƒåœ¨ç²¾ç¡®åº¦ä¸Šä¼šæœ‰é—®é¢˜
                - é¿å…åœ¨æµ®ç‚¹æ•°ä¸Šæµ‹è¯•ç›¸ç­‰æ€§
                - å½“ç»“æœåœ¨æ•°å­¦ä¸Šå¯èƒ½å­˜åœ¨æœªå®šä¹‰æ—¶ï¼Œéœ€è¦æ ¼å¤–å°å¿ƒ
    */

    let _x = 2.0;  // f64 é»˜è®¤æ˜¯f64
    let _u:f32 = 3.0;  // f32

    // æ–­è¨€ 0.1 + 0.2 ä¸ 0.3ç›¸ç­‰
    // assert!(0.1 + 0.2 == 0.3); // æŠ¥é”™ï¼Œå› ä¸ºå°æ•°ç‚¹Nä½å­˜åœ¨è¯¯å·®

    // è§£å†³: é€šè¿‡ç²¾ç¡®åº¦å»è§£å†³
    let abc: (f32, f32, f32) = (0.1, 0.2, 0.3);
    println!("abc (f32)");
    // f32çš„ç²¾ç¡®åº¦æ˜¯ä¸€è‡´çš„ï¼Œæ‰€ä»¥è¿›è¡Œæ¯”è¾ƒæ˜¯ç›¸åŒçš„
    println!("  0.1 + 0.2 : {:x}", (abc.0 + abc.1).to_bits());  // .to_bits() è·å–ç²¾ç¡®åº¦
    println!("        0.3 : {:x}", (abc.2).to_bits());
    println!();

    let xyz: (f64, f64, f64) = (0.1, 0.2, 0.3);
    println!("xyz (f64)");
    // f64çš„ç²¾ç¡®åº¦æ˜¯ä¸ä¸€è‡´çš„ï¼Œæ‰€ä»¥è¿›è¡Œæ¯”è¾ƒä¼šå‡ºé—®é¢˜
    println!("  0.1 + 0.2 : {:x}", (xyz.0 + xyz.1).to_bits());
    println!("        0.3 : {:x}", (xyz.2).to_bits());
    println!();

    // f32 ä¸ f64 çš„æ–­è¨€
    assert!(abc.0 + abc.1 == abc.2);  // æ–­è¨€é€šè¿‡
    // assert!(xyz.0 + xyz.1 == xyz.2);  // æ–­è¨€å¤±è´¥

    // NaN 
    // å¯¹äºæ•°å­¦ä¸Šæœªå®šä¹‰çš„ç»“æœï¼Œä¾‹å¦‚å¯¹è´Ÿæ•°å–å¹³æ–¹æ ¹ -42.1.sqrt()ï¼Œä¼šäº§ç”Ÿä¸€ä¸ªç‰¹æ®Šçš„ç»“æœï¼Œrustç±»å‹ä¸ºNaNï¼ˆnot a numberï¼‰
    // NaNä¸èƒ½ç”¨äºæ¯”è¾ƒï¼Œå¦åˆ™ä¼šå´©æºƒ
    let x2 = (-42.0_f32).sqrt(); // å¾—åˆ°-42.0ä¸ºf32çš„å¹³æ–¹æ ¹ï¼Œä¸ºNaNç±»å‹
    // assert_eq!(x2, x2);  // NaN ä¸ NaN æ¯”è¾ƒ

    // ä¸ºäº†é¿å…æŠ¥é”™ï¼Œrustæä¾›äº† si_nan() ç­‰æ–¹æ³•ï¼Œå¯ä»¥ç”¨äºåˆ¤æ–­ä¸€ä¸ªå€¼æ˜¯å¦ä¸ºNaNç±»å‹
    if x2.is_nan(){
        println!("æœªå®šä¹‰çš„æ•°å­¦è¡Œä¸º!");
    }

    /*
        3ã€æ•°å­—è¿ç®—
            åŠ ã€å‡ã€ä¹˜ã€é™¤ã€æ±‚ä½™

            æ³¨æ„: åªæœ‰åŒæ ·ç±»å‹æ‰èƒ½è¿›è¡Œè¿ç®—

    */

    let num1 = 20;  // é»˜è®¤i32ç±»å‹
    let num2:i32 = 22;  //ç±»å‹æ ‡æ³¨ä¸ºi32
    let num3 = 24i32;  //ç±»å‹åç¼€æŒ‡å®ši32ç±»å‹

    // ç›¸åŒç±»å‹æ‰èƒ½è¿›è¡Œè¿ç®—
    let add = num1 + num2 + num3;
    println!("{} + {} + {} = {}", num1, num2, num3, add);

    // å¯¹äºè¾ƒé•¿çš„æ•°å­—ï¼Œå¯ä»¥ç”¨_è¿›è¡Œåˆ†å‰²ï¼Œæå‡å¯è¯»æ€§;
    let one_million:i64 = 1_000_000;
    println!("{}", one_million);


    // å®šä¹‰ä¸€ä¸ªf32æ•°ç»„ï¼Œå…¶ä¸­50.0ä¼šè¢«è‡ªåŠ¨æ¨å¯¼ä¸ºf32ç±»å‹
    let float_array = [
        50.0,
        51f32,
        52.0_f32,
    ];
    // ä¿ç•™ä¸¤ä½å°æ•°æ ¼å¼åŒ–è¾“å‡º
    println!("{:.2}", float_array[0]);

    /*
        4ã€ä½è¿ç®—
            &ä¸ã€|æˆ–ã€^å¼‚æˆ–ï¼ˆç›¸åŒä½ç½®ä¸åŒåˆ™ä¸º1ï¼Œç›¸åŒä¸º0ï¼‰ã€!éã€<<å·¦ç§»ï¼ˆå‘å·¦ç§»æŒ‡å®šä½æ•°ï¼‰ã€>>å³ç§»
    */
    // äºŒè¿›åˆ¶ä¸º 00000010
    let a1:i32 = 2;
    // äºŒè¿›åˆ¶ä¸º 00000100
    let b1:i32 = 3;
    println!("(a1 & b1) value is {}", a1 & b1);
    println!("(a1 | b1) value is {}", a1 | b1);
    println!("(a1 ^ b1) value is {}", a1 ^ b1);  // æ¯”è¾ƒä¸¤ä¸ªå˜é‡ä¸åŒä¸º1ï¼Œç›¸åŒä¸º0
    println!("(a1 ! b1) value is {}", !b1); // ä½å–å -4
    println!("(a1 << b1) value is {}", a1 << b1); // äºŒè¿›åˆ¶ä¸º 00000010000  16
    println!("(a1 >> b1) value is {}", a1 >> b1); // äºŒè¿›åˆ¶ä¸º 0000000.1     0
    // æ³¨æ„: é™¤äº† ! è¿ç®—ç¬¦ä»¥å¤–ï¼Œå…¶ä»–éƒ½å¯ä»¥åŠ ä¸Š = è¿›è¡Œèµ‹å€¼
    let mut a1 = a1;  // å®šä¹‰å¯å˜é‡a2
    a1 <<= b1;
    println!("(a1 << b1) value is {}", a1);


    /*
        5ã€åºåˆ—ï¼ˆRangeï¼‰
            Rustæä¾›äº†ä¸€ä¸ªéå¸¸ç®€æ´çš„æ–¹å¼ï¼Œç”¨æ¥ç”Ÿæˆè¿ç»­çš„æ•°å€¼ï¼Œä¾‹å¦‚ 1..5ï¼Œç”Ÿæˆä»1-4çš„è¿ç»­æ•°å­—ï¼Œä¸åŒ…å«5ï¼Œé¡¾å¤´ä¸é¡¾å°¾;

            0-N
            a-z
    */
    // 1..=5 åŒ…å«5
    for i in 1..=5 {  
        println!("{}", i);
    }

    // 1..5 ä¸åŒ…å«5  é¡¾å¤´ä¸é¡¾å°¾
    for i2 in 1..5{
        println!("{}", i2)
    }

    // æ³¨æ„: åºåˆ—åªå…è®¸ç”¨äºæ•°å­—æˆ–å­—ç¬¦ç±»å‹ï¼ŒåŸå› æ˜¯å¯ä»¥è¿ç»­ï¼ŒåŒæ—¶ç¼–è¯‘å™¨åœ¨ç¼–è¯‘æ—¶å¯ä»¥æ£€æŸ¥è¯¥åºåˆ—æ˜¯å¦ä¸ºç©ºï¼Œ
    // å­—ç¬¦å’Œæ•°å­—å€¼æ˜¯rustä¸­ä»…æœ‰å¯ä»¥åˆ¤æ–­æ˜¯å¦ä¸ºç©ºçš„ç±»å‹
    for i3 in 'a'..='z' {
        println!("{}", i3);
    }

    /*
        6ã€æœ‰ç†æ•°å’Œå¤æ•°
            - æœ‰ç†æ•°å’Œå¤æ•°ã€‚
            - ä»»æ„å¤§å°çš„æ•´æ•°å’Œä»»æ„ç²¾åº¦çš„æµ®ç‚¹æ•°ã€‚
            - å›ºå®šç²¾åº¦çš„åè¿›åˆ¶å°æ•°ï¼Œå¸¸ç”¨äºè´§å¸ç›¸å…³çš„åœºæ™¯ã€‚
        
        - é€šè¿‡ç¬¬ä¸‰æ–¹çš„åº“æ¥å®ç°: num
            1.åœ¨Cargo.toml ä¸­çš„ [dependencies] ä¸‹æ·»åŠ ä¸€è¡Œ num = "0.4.0" ;
            2.åœ¨src/main.rs æ–‡ä»¶çš„å¼€å¤´ é€šè¿‡ use num::complex::Complex; æ–¹å¼å¯¼å…¥;
            3.ç¼–å†™ä»£ç ï¼Œå¹¶ç¼–è¯‘æ‰§è¡Œ;
    */
    let d = Complex {re: 2.1, im: -1.2};
    let e = Complex::new(11.1, 22.2);
    let result = d + e;  // d.re + e[0] , d.im + e[1]
    println!("{} = {}", result.re, result.im); // 13.2 = 21

    /*
    æ•°å€¼ç±»å‹æ€»ç»“:
        rustçš„æ•°å€¼ç±»å‹ä¸å…¶ä»–è¯­è¨€è¾ƒä¸ºç›¸ä¼¼ï¼Œä½†æ˜¯å®é™…ä¸Šï¼Œé™¤äº†è¯­æ³•ä¸åŒä¹‹å¤–ï¼Œè¿˜å­˜åœ¨ä¸€äº›å·®å¼‚:
            1.Rust æ‹¥æœ‰ç›¸å½“å¤šçš„æ•°å€¼ç±»å‹ï¼Œå› æ­¤éœ€è¦ç†Ÿæ‚‰è¿™äº›ç±»å‹æ‰€å ç”¨çš„å­—èŠ‚æ•°ï¼Œæ‰èƒ½çŸ¥é“ä¸åŒç±»å‹çš„å¤§å°èŒƒå›´ã€æ˜¯å¦ä¸ºè´Ÿæ•°;
            2.ç±»å‹è½¬æ¢å¿…é¡»æ˜¯æ˜¾å¼çš„ï¼Œrust æ°¸è¿œä¹Ÿä¸ä¼šå·å·å°† 16bit æ•´æ•°è½¬ä¸º 32bit çš„æ•´æ•°;
            3.Rustçš„æ•°å€¼ä¸Šå¯ä»¥ä½¿ç”¨æ–¹æ³•, ä¾‹å¦‚å¯ä»¥ç”¨ä»¥ä¸‹çš„æ–¹æ³•æ¥å°† 13.14 å–æ•´ï¼Œ 13.14_f32.round(), ä½†å‰æè¦é€šè¿‡
            _f32æŒ‡å®šç±»å‹ï¼Œè¿™æ ·ç¼–è¯‘å™¨æ‰èƒ½çŸ¥é“13.14çš„å…·ä½“ç±»å‹;
    */
}


/*
    å­—ç¬¦ä¸²ã€å¸ƒå°”ã€å•å…ƒç±»å‹:
        å­—ç¬¦: char
        å¸ƒå°”: bool  true  false
        å•å…ƒ: ()
*/ 
fn str_bool_type(){
    // å­—ç¬¦ä¸² char
    let _a = 'a';
    let _b = 'B';
    let c = 'å›½';
    let _heart_eyed_cat = 'ğŸ±';  //ç«Ÿç„¶å¯ä»¥ç”¨è¡¨æƒ…æ¥åšå­—ç¬¦
    // Unicode ä¸€ä¸ªå­—ç¬¦å ç”¨4ä¸ªå­—èŠ‚
    println!("å­—ç¬¦ 'å›½' å ç”¨äº†{}å­—èŠ‚çš„å†…å­˜å¤§å°", std::mem::size_of_val(&c));
    println!("å­—ç¬¦ 'ğŸ±' å ç”¨äº†{}å­—èŠ‚çš„å†…å­˜å¤§å°", std::mem::size_of_val(&_heart_eyed_cat));

    // å¸ƒå°” bool
    let _t = true;
    let f:bool = false;
    if f {
        println!("è¿™æ®µä»£ç æ¯«æ— æ„ä¹‰!");
    }

    // å•å…ƒç±»å‹ ()


}


/*
    è¯­å¥ã€è¡¨è¾¾å¼
        rustå‡½æ•°ä½“ä»£ç æ˜¯ç”±è¯­å¥å’Œè¡¨è¾¾å¼ç»„æˆ;
*/
fn func(){
    // è¯­å¥  let
    let _a = 10;
    let _b:Vec<f64> = Vec::new();
    let (_a, _c) = ("hi", false);

    // è¡¨è¾¾å¼  ä¸¤ä¸ªå˜é‡ä¹‹é—´çš„è¿ç®—è¡¨è¾¾å¼
    let y = { // ç›¸å½“äºä¸€ä¸ªåŒ¿åå‡½æ•°ï¼Œå¹¶ä¸”é»˜è®¤ return x + 1
        let x = 100; 
        x + 1 // è¡¨è¾¾å¼    return  100 + 1
    };
    
    println!("The value of y is: {}", y);  // 101
}

// è‹¥è¡¨è¾¾å¼ä¸è¿”å›ä»»ä½•å†…å®¹ï¼Œåˆ™éšå¼è¿”å›ä¸€ä¸ª () å•å…ƒ;
fn ret_unit_type(){
    // è‹¥è¡¨è¾¾å¼ä¸è¿”å›ä»»ä½•å†…å®¹ï¼Œåˆ™éšå¼è¿”å›ä¸€ä¸ª () å•å…ƒ;
    let z = 1;
    if z > 1 {
    }
}


/*
    å‡½æ•°å®šä¹‰: 
        fn: å®šä¹‰å…³é”®å­—
        add: å‡½æ•°å
        (i:i32, j:i32): æ¥æ”¶å‚æ•°åä¸ç±»å‹
        -> i32: è¿”å›å€¼ç±»å‹
        {}: å‡½æ•°ä½“

    å‡½æ•°å‚æ•°:Rustæ˜¯å¼ºç±»å‹è¯­è¨€ï¼Œå› æ­¤éœ€è¦ä½ ä¸ºæ¯ä¸ªå‡½æ•°å‚æ•°æ ‡è¯†å…·ä½“çš„ç±»å‹;

    å‡½æ•°æ— è¿”å›å€¼:
        - å‡½æ•°æ²¡æœ‰è¿”å›å€¼åˆ™ä¼šè¿”å› ()
        - é€šè¿‡ ; ä½œä¸ºç»“å°¾çš„è¡¨è¾¾å¼ä¼šè¿”å› ()
*/
// å‡½æ•°å®šä¹‰
fn add(i:i32, j:i32) -> i32{
    i + j  // return i + j
}

// å‡½æ•°å‚æ•°
fn another_function(x: i32, y: i32){
    println!("The value of x is: {}", x);
    println!("The value of y is: {}", y);
}

// å‡½æ•°è¿”å›å€¼
fn plus_five(i: i32) -> i32{
    i + 5
}

// å‡½æ•°æ— è¿”å›å€¼ï¼Œåˆ™ä¼šè¿”å› ()
use std::fmt::Debug;
fn report<T:Debug>(item: T){  // å¯æ¥æ”¶ä»»æ„ç±»å‹
    println!("{:?}", item);
}

fn main(){
    // // æ•°å€¼ç±»å‹
    number_type();
    println!();
    println!();

    // å­—ç¬¦ä¸²ã€å¸ƒå°”ã€å•å…ƒç±»å‹
    str_bool_type();
    println!();
    println!();

    // è¯­å¥ã€è¡¨è¾¾å¼
    func();
    assert_eq!(ret_unit_type(), ());

    // å‡½æ•°
    let result = add(100, 200);
    println!("add func return value: {}", result);
    
    // å‡½æ•°å‚æ•°
    another_function(9527, 8080);
    // another_function(9527, 10.1);  // å‚æ•°2ä¼ é€’f64çš„ç±»å‹åˆ™ä¼šæŠ¥é”™

    // å‡½æ•°è¿”å›å€¼
    let ret = plus_five(9522);
    println!("plus_five function return value is: {}", ret);

    // å‡½æ•°æ— è¿”å›å€¼ï¼Œåˆ™ä¼šè¿”å› ()
    report(100);
}
